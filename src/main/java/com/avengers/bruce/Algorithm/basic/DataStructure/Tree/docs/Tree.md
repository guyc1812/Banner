# Tree

## 索引顺序存取法（ISAM，Indexed Sequential Access Method）

* 关于存储

    ![image](https://oss.guyuchen.com/deadpool/images/cipan.jpg)
    
    磁盘是一个扁平的圆盘，盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。<br>
    磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。<br>
    如上图，除去最顶端和最底端的外侧面不存储数据之外，一共有10个面可以用来保存信息。
    
    当磁盘驱动器执行读/写功能时。<br>
    盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头(又叫磁头)下通过时，就可以进行数据的读/写了。
    
    一般磁盘分为固定头盘(磁头固定)和活动头盘。
    
    固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。
    
    活动头盘 (如上图)的磁头是可移动的。每一个盘面上只有一个磁头(磁头是双向的，因此正反盘面都能读写)。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的(行动整齐划一)。<br>
    当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面。<br>
    因此，柱面的个数也就是盘面上的磁道数。
    
* 磁盘的读 / 写原理和效率

    磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。
    
    读/写磁盘上某一指定数据需要下面3个步骤：
    
    1. 首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找 。
    1. 如上图中所示的6盘组示意图中，所有磁头都定位到了10个盘面的10条磁道上(磁头都是双向的)。这时根据盘面号来确定指定盘面上的磁道。
    1. 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。
    
    经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读/写操作了。
    　　
    访问某一具体信息，由3部分时间组成：
    
    * 查找时间(seek time) Ts: 
        完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。
    * 等待时间(latency time) Tl: 
        完成上述步骤(3)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分，因此一般旋转一圈大约0.0083s。<br>
        (电脑硬盘的性能指标之一, 家用的普通硬盘的转速一般有5400rpm(笔记本)、7200rpm几种)
　　 * 传输时间(transmission time) Tt: 
        数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概0.02us=2*10^(-8)s<br>
        磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。<br>
        而磁盘IO代价主要花费在查找时间Ts上。 <br>
        因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。<br>
        所以，在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构。<br>
        这种结构可以使得在查找过程中，IO次数尽量的少。
  
## BST - Binary Search Tree

   二叉查找树，也称有序二叉树 , 排序二叉树：
   
   * 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
   * 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
   * 任意节点的左、右子树也分别为二叉查找树。
   * 没有键值相等的节点（no duplicate nodes）。
   * 中序遍历有序
   
## Attributes of Tree

* 在二叉树的第i层上至多有2^(i-1)个结点(i>=1)
* 深度为k的二叉树至多有2^k-1个结点(k>=1)
* 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1（设度为一的结点数为n!，利用结点数与边数的关系。）
* 具有n个结点的完全二叉树的深度为⌊log₂n⌋+1
* 如果对一棵有n个结点的完全二叉树(其深度为⌊log₂n⌋+1)的结点按层序编号，对任一结点i(1<=i<=n)有以下性质：
    * 如果i = 1，则结点 i 是二叉树的根，无双亲；如果i > 1，则其双亲是结点⌊i/2⌋
    * 如果2i > n，则结点 i 无做左孩子(结点 i 为叶子结点)；否则其左孩子是结点2i
    * 如果2i+1 > n，则结点 i 无右孩子；否则其右孩子是结点2i+1


## Balance Tree

* 多路树：

    * 2-3 Tree
    * B Tree
    * B+ Tree
    * B* Tree

* 二叉树：

    * AVL Tree
    * BR Tree

### 2-3 Tree

1. 所有节点只包含2或3个子节点，等同于4阶B树
1. 当出现4-node时，4-node中三个值中间的那个向上合并，当根节点也为4-node时，高度 + 1
1. 中序遍历有序

### B Tree

![image](https://oss.guyuchen.com/deadpool/images/btree.jpg)

* **性质**

    * m阶表示,树中每个结点最多含有m个孩子（m>=2）；
    * 除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足： (ceil(m/2)-1)<= n <= m-1
    * 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息
    * 每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)
        * Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki
        * Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)
        
* **插入**

    1. 插入以下字符字母到一棵空的B树中（非根结点关键字数小于2就合并，超过4就分裂）：C N G A H E K Q M F W L T Z D P R X Y S <br>
        首先，结点空间足够，4个字母插入相同的结点中，如下图： 
        
        ![image](https://oss.guyuchen.com/deadpool/images/btree1.jpg)
            
    1. 试着插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中，在实现过程中，把A和C留在当前结点中，而H和N放置新的其右邻居结点中。如下图：
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree2.jpg)
        
    1. 插入E,K,Q时，不需要任何分裂操作 
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree3.jpg)
    
    1. 插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree4.jpg)        
    
    1. 插入F,W,L,T不需要任何分裂操作 
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree5.jpg)

    1. 插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。 
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree6.jpg)
    
    1. 插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作（树中至多5个孩子）。 
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree7.jpg)

    1. 最后，当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括D和G节点中。这样具体插入操作的完成，下面介绍删除操作，删除操作相对于插入操作要考虑的情况多点。 
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree8.jpg)

* **删除**

    小于 ceil(m / 2)-1 合并<br>
    中间节点删除，<br>
    若存在丰满子树，其丰满子节点上移，旋转<br>
    若无丰满节点，其子节点合并<br>
    叶节点删除，<br>
    若满足 (ceil(m/2)-1) <= n <= m-1 ，则直接删除<br>
    若兄弟丰满，则左旋(右旋)<br>
    若兄弟不丰满，取父节点向下合并，再调整父节点
    
    依次删除H,T,R,E。
    
    1. 首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree9.jpg)
    
    1. 下一步，删除T,因为T没有在叶子结点中，而是在中间结点中找到，发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作。
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree10.jpg)
        
    1. 下一步删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,<br>
        而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有没有看到红黑树中左旋操作的影子?），<br>
        在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；<br>
        然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。

        ![image](https://oss.guyuchen.com/deadpool/images/btree11.jpg)
        
    1. 最后一步删除E，删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,<br>
        而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；<br>
        首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，<br>
        然后将这两个结点进行合并成一个结点。<br>
        所以在该实例中，首先将父节点中的元素D下移到已经删除E而只有F的结点中，<br>
        然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。
        
        ![image](https://oss.guyuchen.com/deadpool/images/btree12.jpg)
        
    1. 对于这种特殊情况，会发现父节点只包含一个元素G，没达标（因为非根节点包括叶子结点的关键字数n必须满足于2=<n<=4，而此处的n=1），这是不能够接受的。<br>
        如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。<br>
        假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），<br>
        然后将M下移到元素很少的子结点中，将Q上移到M的位置，<br>
        这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。<br>
        所以在这个实例中，没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，<br>
        而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。
        
        ![image](https://oss.guyuchen.com/deadpool/images/btree13.jpg)
        
    * 为了进一步详细讨论删除的情况，再举另外一个实例：这里是一棵不同的5序B树，删除C
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree14.jpg)
        
        于是将删除元素C的右子结点中的D元素上移到C的位置，但是出现上移元素后，只有一个元素的结点的情况。<br>
        又因为含有E的结点，其相邻兄弟结点才刚脱贫（最少元素个数为2），不可能向父节点借元素，所以只能进行合并操作，<br>
        于是这里将含有A,B的左兄弟结点和含有E的结点进行合并成一个结点。
        
        ![image](https://oss.guyuchen.com/deadpool/images/btree15.jpg)
        
        这样又出现只含有一个元素F结点的情况，<br>
        这时，其相邻的兄弟结点是丰满的（元素个数为3>最小元素个数2），<br>
        这样就可以想父结点借元素了，把父结点中的J下移到该结点中，相应的如果结点中J后有元素则前移，<br>
        然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，<br>
        后面的元素（或者前面的元素）前移（或者后移）；<br>
        注意含有K，L的结点以前依附在M的左边，现在变为依附在J的右边。<br>
        这样每个结点都满足B树结构性质。
    
        ![image](https://oss.guyuchen.com/deadpool/images/btree16.jpg)
        
### B+ Tree

B+-tree：是应文件系统所需而产生的一种B-tree的变形树。

![images](https://oss.guyuchen.com/deadpool/images/bptree.jpg)

* **性质**
    
    1. 有n棵子树的结点中含有n-1 个关键字；    
    2. 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。
    3. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。
    
* **为什么说 B+ Tree 比 B Tree 更适合实际应用中操作系统的文件索引和数据库索引？**
    
    1. B+ tree的磁盘读写代价更低
    
        B+ tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。<br>
        如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。<br>
        一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
    
        举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。<br>
        一棵9阶B tree(一个结点最多8个关键字)的内部结点需要2个盘快, 而 B+ tree 内部结点只需要1个盘快。<br>
        当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。
    
    2. B+ tree的查询效率更加稳定
    
        由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。<br>
        所以任何关键字的查找必须走一条从根结点到叶子结点的路。<br>
        所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。<br>
    
### B* Tree

B*-tree是B+-tree的变体，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，
B*树中非根和非叶子结点再增加指向兄弟的指针；
B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）。

![images](https://oss.guyuchen.com/deadpool/images/bstree.jpg)

* B+树的分裂：<br>
    当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；<br>
    B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。

* B*树的分裂：<br>
    当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；<br>
    如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。

所以，B*树分配新结点的概率比B+树要低，空间使用率更高；
    
### AVL - Tree

* **Balance factor**
  
    平衡因子：对于任意节点 x ，其平衡因子定义为该节点右子树和左子树高度差。<br>
    bf（x）=h（x-right）-h（x-left）。
    
    带有平衡因子1、0或 -1的节点被认为是平衡的。<br>
    带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。
    
    旋转： RR, LL, RL, LR
    
* **为什么BR-Tree而不是AVL-Tree**

    如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；<br>
    但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，<br>
    而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。
 
    其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，<br>
    因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。<br>
    BR-Tree在需要大量插入和删除node的场景下，效率更高。<br>
    自然，由于AVL高度平衡，因此AVL的search效率更高。
    
    map的实现只是折衷了两者在search、insert以及delete下的效率。<br>
    总体来说，RB-tree的统计性能是高于AVL的。

    
